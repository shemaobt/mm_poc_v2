# Meaning Map Data Storage & Flow Explained

This document explains how the **Meaning Map (TRIPOD) results** are stored, persisted, and retrieved in the system.

## 1. Core Concept: Normalized Relational Storage

Unlike some document-based systems that might save the final result as a single large JSON blob (like `result.json`), this system uses a **fully normalized relational database structure**.

The "Final Meaning Map" is actually a collection of linked rows across several tables.

### Key Tables
The data for a single meaning map is distributed across these tables, all linked to the central `Passage`:

*   **`passages`**: The root record. Contains metadata like reference (`Gen 1:1`), status (`isComplete`), and peak event.
*   **`events`**: Every event identified in Stage 4.
*   **`participants`**: People/entities identified in Stage 2.
*   **`participant_relations`**: Relationships defined in Stage 3 (e.g., kinship).
*   **`discourse_relations`**: High-level connections between events defined in Stage 5.
*   **`event_roles`**: Links `events` to `participants` (e.g., "Noah" is the "doer" of "built").

### Why this approach?
*   **Live Editing**: As you work through Stages 1-5, every change (adding a participant, linking an event) is immediately saved to its specific table. There is no "unsaved work" in the traditional sense.
*   **Query Efficiency**: We can query specifically for "all events in Genesis" without parsing massive JSON blobs.

---

## 2. The "Complete & Save" Action

When you click **"Complete & Save"** at the end of Stage 5, the system does **not** move data to a new location.

Instead, it essentially does the following:
1.  **Mark as Complete**: Updates the `isComplete` boolean flag in the `passages` table to `true`.
2.  **Timestamp**: Sets the `completedAt` timestamp.

The data remains in the same relational tables (`events`, `participants`, etc.) where it has lived throughout the editing process.

```typescript
// backend/app/api/export.py

// When you finalize:
await db.passage.update(
    where={"id": passage_id},
    data={
        "isComplete": True,
        "completedAt": datetime.now()
    }
)
```

---

## 3. What is the `ai_snapshots` table?

You may see a table called `ai_snapshots` containing JSON data. **This is NOT the final result.**

*   **Purpose**: This table stores the **initial raw output** generated by the AI when you first ran the "AI Prefill".
*   **Usage**: It is used solely for **metrics calculations**.
    *   The system compares the *Snapshot* (what AI gave you) vs. the *Live Data* (what you finished with).
    *   This allows us to calculate "AI Accuracy" (e.g., "User kept 80% of AI suggestions, modified 10%, and added 10% new items").

**Do not look at `ai_snapshots` for the final meaning map.** It is a historical record of the starting point.

---

## 4. Exporting the Result

When you want to download or view the "Final JSON" (e.g., for the visualization tool or export), the system **re-assembles** it on the fly.

It queries all the normalized tables and constructs the standard Tripod JSON schema:

```python
# The structure is built dynamically from the database rows
output = {
    "participants": [ ... rows from participant table ... ],
    "events": [ ... rows from event table ... ],
    # ... etc
}
```

## Summary Table

| Component | Storage Location | When is it updated? |
| :--- | :--- | :--- |
| **Live Editor Data** | `participants`, `events`, `relations` tables | Immediately on every edit |
| **Final Result** | Same as above (Virtual view) | Always current |
| **Completion Status** | `passages.isComplete` | When clicking "Complete & Save" |
| **AI Baseline** | `ai_snapshots.snapshotData` | Only once, during initial AI Prefill |
